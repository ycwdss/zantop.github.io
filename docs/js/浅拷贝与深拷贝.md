# 浅拷贝与深拷贝

说到对象的引用先看个例子：

```javascript
var a = 5;
var b = a;
b += 3;

alert(b); //8
alert(a); //5
```

<!--more-->

像这种简单的赋值关系，把 a 赋给 b,b 的值的改变不会影响到 a,
这种关系存在哪些类型中呢，字符串，布尔值，undefined……都有这种属性。
然而对于对象，有什么样的关系呢？
例一：

```javascript
var a = [1, 2, 3];
var b = a;
b.push(4);

alert(b); //1,2,3,4
alert(a); //1,2,3,4
```

这种不是赋值的关系，对象和函数都是引用的关系了
在内存中 a 有一条地址，它把这个地址引用给了 b,共用了同一条地址，这样 b 的改变会影响到 a.
例二：

```javascript
var a = [1, 2, 3];
var b = a;
b = [1, 2, 3, 4];

alert(b); //1,2,3,4
alert(a); //1,2,3
```

不是说把 a 的引用给了 b 了吗，但是这种情况呢，`在内存中a有一条地址，它把这个地址引用给了b,共用了同一条地址`
这句话是没错的，`b = [1,2,3,4]`;只要赋值在内存中就开辟了给新地址给 b，之前与 a 共用的地址给分离了 b 的改变不会影响到 a。
例子：

```javascript
var a = 1;
var b = 1;
alert(a == b); //true 基本类型只要值相等就可以
var a = [1, 2, 3];
var b = [1, 2, 3];
alert(a == b); //false 对象类型 值和引用都相同可以
```

思考上面的区别。

```javascript
var obj = {
  a: 10,
};
var obj2 = obj;
obj2.a = 20;

alert(obj.a); //20
```

赋值一个对象 obj 给另一个对象 obj2，当改变 obj2 的时候回影响到 obj 对象，这是我们不希望看到的，怎么解决这个问题呢？

## 浅拷贝

## 1、Object.assign

```
let a = {
    age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```

## 2、结构解析

```
let a = {
    age: 1
}
let b = {...a}
a.age = 2
console.log(b.age) // 1
```

## 3、遍历

```javascript
var obj = {
  a: 10,
};
function copy(obj) {
  //浅拷贝
  var newObj = {};
  for (var attr in obj) {
    newObj[attr] = obj[attr]; //里面每个值都复制给新对象并返回
  }
  return newObj;
}
var obj2 = copy(obj);
obj2.a = 20;
alert(obj.a); //10
```

这种在 js 中叫做浅拷贝，为什么叫浅拷贝呢，因为在拷贝中有点小问题，下下面的例子：

```javascript
var obj = {
  a: { b: 10 },
};
function copy(obj) {
  //浅拷贝
  var newObj = {};
  for (var attr in obj) {
    newObj[attr] = obj[attr];
  }
  return newObj;
}
var obj2 = copy(obj);
obj2.a.b = 20;
alert(obj.a.b); //20
```

浅拷贝只是拷贝了一层，还是会影响到原来的 obj

对于不管多少层，对于这种情况要进行深拷贝来处理了，运用递归的方式。
拓展一下递归：

## 深拷贝

## 1、JSON.parse(JSON.stringify(object))

```
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

但是该方法也是有局限性的：

- 会忽略 undefined
- 不能序列化函数
- 不能解决循环引用的对象

## 2、递归

```javascript
//递归：
//1.函数调用函数自身，执行递的动作
//2.最后一次判断一个终止条件，可以执行归的动作
function test(n) {
  if (n == 1) {
    console.trace();
    return 1;
  }
  return n * test(n - 1);
}
alert(test(4)); //阶乘
```

```javascript
var obj = {
  a: { b: 10 },
};
function deepCopy(obj) {
  //深拷贝
  if (typeof obj != 'object') {
    console.trace();
    return obj;
  }
  var newObj = {};
  for (var attr in obj) {
    newObj[attr] = deepCopy(obj[attr]);
  }
  return newObj;
}
var obj2 = deepCopy(obj);
obj2.a.b = 20;
alert(obj.a.b); //10
```

[js 深拷贝 vs 浅拷贝](https://juejin.im/post/59ac1c4ef265da248e75892b)
